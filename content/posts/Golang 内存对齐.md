---
title: "Golang 内存对齐"
date: 2021-04-23T00:32:28+08:00
draft: false
original: true
categories: 
  - Golang
tags: 
  - Golang基础
---

### struct对象占用多大的内存？

基本类型比如int64，int32等我们清楚的知道会占用多大的内存，但是对于struct这种复合类型，如何知道占用多大的内存呢？struct中每个字段类型占用的内存总和吗？今天我们就来讨论一下这个问题。

首先先测试一下，下面的2个结构体占用多大的空间

```go
type T1 struct {
	A uint8  //1
	B uint16 //2
	E uint8  //1
	C uint32 //4
	D uint64 //8
}

type T2 struct {
	A uint8  //1
	E uint8  //1
	B uint16 //2
	C uint32 //4
	D uint64 //8
}

unsafe.Sizeof(t1) // 24
unsafe.Sizeof(t2) // 16
```

不知道有没有回答正确，反正我第一次是没有回答正确的，接下来让我来说一下我的理解过程。

<!--more-->

### struct的内存布局

复合类型就是内部包含多种数据类型的数据类型，它们都是存储在一块连续的内存空间中，struct在golang中就是其内部字段在内存中逐个排列的。这个和Java对象不同，Java对象还包含对象头信息，而golang是没有对象头的。

先来看看T1和T2在内存中的布局情况：

![T1T2内存分布](/Golang内存对齐/T1T2内存分布.png)


T1和T2的内存布局

### 为什么需要内存对齐

从T1和T2的内存布局图可以看出，T2比T1排列更加紧凑，虽然它们存储的字段内容是一样的，仅仅是字段换了一下顺序，T2就比T1占用的内存更小。

在T1中留空的地方就是我们说的内存对齐了。那么为什么需要内存对齐呢？一个字段挨着一个字段排队站好不行吗？

这个就设计到计算机的设计有关了，我们的数据都是丢给CPU进行计算的，而我们的数据是在内存中，当CPU需要获取数据进行计算的时候，需要从内存中获取值，就需要通过数据总线从内存只能够获取数据，而数据总线是有宽度的，也就是一次最多读取多少的数据，一般是32位或64位，也就是一次能获取32bit或64bit的数据，这个长度成为字长，所以CPU从内存中获取数据是以字长位单位的，就需要进行内存对齐。

如果有了内存对齐，CPU就能从内存中读取到完成的数据，避免了数据被分割。比如我们的数据是2，2，1，1，1，2，没有内存对齐，CPU一次读取8字节的数据，最后的那个2字节的数据就会被分成2次读取，这反而增加的复杂性。

### 内存对齐规则

最开始我也没有理解到内存对齐规则，简单的认为64位只要最后struct{}的大小是是8字节的倍数就行了，但是前面问题中的T1、T2，在不考虑对齐的情况下它们的字段所占用的大小都是16字节，为什么T1最后会占用24字节呢？这就是没有理解对齐规则

在参考资料[golang 内存分析之字节对齐规则](https://my.oschina.net/u/2950272/blog/1829197)中提到了C语言中的对齐规则

1. 数据成员对齐规则：结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，**以后每个数据成员的地址必须是它本身大小或对齐参数两者中较小的一个的倍数**。 
2. 整体对齐规则：在数据成员完成各自对齐之后，结构(或联合)本身也要进行对齐，整体长度必须是对齐参数和结构体最长的元素长度中较小的一个的倍数。

可以发现对齐规则不仅仅和struct总体大小有关，与其中的每个字段的偏移量都有关系，这个规则就是**数据成员的地址必须是它本身大小或对齐参数两者中较小的一个的倍数**

我们来分析一下T1为啥需要24字节

```go
type T1 struct {
	A uint8  //1
	B uint16 //2
	E uint8  //1
	C uint32 //4
	D uint64 //8
}
```

T1的对齐大小是8字节 

- A偏移为0，大小是1字节，0是1的倍数，所以不用管
- B偏移是1，大小是2字节，1不是2的倍数，所以需要对A进行填充，让B的偏移变成2成为2的倍数
- E偏移是4，大小是1字节，4是1的倍数，所以不用对B进行填充
- C偏移是5，大小是4字节，5不是4的倍数，所以需要对E进行填充，让C的偏移变成8成为4的倍数
- D偏移是12，大小是8字节 ，12不是8的倍数，所以需要对C进行填充，让D的偏移变成16成为8的倍数

所以最后T1占用的空间大小是24字节

这里有个注意点，在32位系统中，对8byte的数据保证原子操作的时候 ，需要调用方保证是8字节对齐的。可以参考[https://github.com/talkgo/night/issues/588#issuecomment-609398875](https://github.com/talkgo/night/issues/588#issuecomment-609398875)

### struct{}空结构

struct{}在不同位置，内存可能会存在差异

#### struct {} 在最前面

这种场景非常好理解，struct {} 字段类型在最前面，这种类型不占空间，所以自然第二个字段的地址和整个变量的地址一致。

```go
// Object1 类型变量占用 1 个字节
type Object1 struct {
 s struct {}
 b byte
}

// Object2 类型变量占用 8 个字节
type Object2 struct {
 s struct {}
 n int64
}

o1 := Object1{ }
o2 := Object2{ }
```

内存怎么分配？

- `&o1` 和 `&o1.s` 是一致的，变量 `o1` 的内存大小对齐到 1 字节；
- `&o2` 和 `&o2.s` 是一致的，变量 `o2` 的内存大小对齐到 8 字节；

这种分配是满足对齐规则的，编译器也不会对这种 `struct {}` 字段做任何特殊的字节填充。

#### struct {} 在中间

```go
// Object1 类型变量占用 16 个字节
type Object1 struct {
 b  byte
 s  struct{}
 b1 int64
}

o1 := Object1{ }
```

- 按照对齐规则，变量 `o1` 占用 16 个字节；
- `&o1.s` 和 `&o1.b1` 相同；

编译器不会对 `struct { }` 做任何字节填充

#### struct {} 在最后

```go
type Object1 struct {
 b byte
 s struct{}
}

type Object2 struct {
 n int64
 s struct{}
}

type Object3 struct {
 n int16
 m int16
 s struct{}
}

type Object4 struct {
 n  int16
 m  int64
 s  struct{}
}

o1 := Object1 { }
o2 := Object2 { }
o3 := Object3 { }
o4 := Object4 { }
```

编译器在遇到这种 `struct {}`  在**最后一个字段**的场景，会进行特殊填充，`struct { }` 作为最后一个字段，会被填充对齐到前一个字段的大小，地址偏移对齐规则不变；

可以现在心里思考下，`o1`，`o2`，`o3`，`o4`  这四个对象的内存分配分别占多少空间？下面解密：

- 变量 `o1` 大小为 2 字节；
- 变量 `o2` 大小为 16 字节；
- 变量 `o3` 大小为 6 字节；
- 变量 `o4` 大小为 24 字节；

这种情况，需要先把 `struct {}`  按照前一个字段的长度分配 padding 内存，然后整个变量按照地址和长度的对齐规则不变。

为什么需要这么做？因为`struct {}`占用的空间大小为0，如果不在末尾进行填充，当你用指针指向结构体的stuct{}字段的时候，指向了一块不知道是什么的内存地址，对在最后的stuct{}进行填充后就是为了防止这种情况，导致指针指向了一个未知数据的地方

### 拓展知识

假设现在，连续声明了两个 S 的变量 s1, s2，那 s2 的内存地址会是怎样的呢？

![](/Golang内存对齐/扩展知识.png)

因为 s1 和 s2 在内存上是连续的，我们也已知 s1 的大小是 40，那为什么 s2 的地址相对 s1 的地址偏移量却是 48 呢？`(0xc0000aa090-0xc0000aa060 = 48)`

先给出答案，因为对于 s1 这个对象，它的大小是 40bytes，而 go 在内存分配时，会从 span 中拿大于或等于 40 的最小的 span 中的一个块给这个对象，而`sizeclass`中这个块的大小值为 48。所以虽然 s1 的大小是 40bytes，但实际分配给这个对象的内存大小是 48。这里涉及到go的内存管理，就不在继续下去了。

### 参考资料

* [Go内存对齐](https://www.cnblogs.com/-wenli/p/12681044.html)
* [Golang最细节篇- struct{} 空结构体究竟是啥？](https://mp.weixin.qq.com/s/2u2qRUbgcOwvU9wcHpC0SA)
* [内存对齐 | 原来字段顺序还能影响结构体占用的内存空间](https://mp.weixin.qq.com/s/l3T5p_iw3S9nm635ezflGQ)
* [golang 内存分析之字节对齐规则](https://my.oschina.net/u/2950272/blog/1829197)
* [golang内存对齐](https://xie.infoq.cn/article/594a7f54c639accb53796cfc7)
* [第 84 期图解 Go 之内存对齐 · Issue #588 · talkgo/night](https://github.com/talkgo/night/issues/588)